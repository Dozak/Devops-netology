# №1
> Узнаем текущую операцию через команду:  
       ```db.currentOp()```


> Прекратим операцию по opid
       ```db.killOp()```

> Существует вариант анализа долгих запросов через explicit. Запросы без указания какого-либо индекса всегда выполняются намного дольше, поэтому нужно построить или перестроить соответствующий индекс.

# №2 

> Как я понимаю, закончился свободный ресурс RAM. 
Redis однопоточен, замедление работы может быть связано с увеличением кол-ва пользователей.

>Redis совершает очистку TTL-записей примерно 20 штук в 100 млс.. Однако если число TTL записей начинает расти, это заставляет Redis блокировать работу, до тех пор пока он все не очистит.
Как вариант поднять 2-ой инстанс и организовать работу в приложении с разными инстансами.

# №3

Скорее всего данная ошибка вылезла из-за того, что произошел рост нагрузки.
Можно предложить следующие варианты:
- Увеличение ресурсов на машине;
- Увеличение параметров: wait_timeout, connect_timeout, interactive_timeout ; (net_read_timeout) - в случае если возникают проблемы с сетью;
- Сделать индексы для оптимизации работы запросов

# №4.

Данная проблема возникает при нехватке RAM. oom-killer всегда будет убивать самый затратный процесс, чтобы не допустить падение всей системы.
Он выставляет каждому процессу оценку - oom_score; на основании которой и выбирает какой процесс убить.

Профилактика для таких проблем заключается в предоставлении больших ресурсов, а также задать ограничение в Postgres на использование хостовых ресурсов.
